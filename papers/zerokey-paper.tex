% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\documentclass[
  11pt,
  a4paper]{article}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\newcounter{none} % for unnumbered tables
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\small,breaklines=true}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={ZeroKey: A Distributed Execution Model Separating Instruction{,} Execution{,} and Accountability in Blockchain Systems},
  pdfkeywords={Blockchain, Smart Contracts, Key Management, AI
Agents, Distributed Systems, Execution Governance},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{ZeroKey: A Distributed Execution Model Separating Instruction,
Execution, and Accountability in Blockchain Systems}
\author{true}
\date{December 2025}

\begin{document}
\maketitle
\begin{abstract}
ブロックチェインシステムは、スマートコントラクトのデプロイおよび資産移動の認可に暗号署名を用いる。この設計において、指示・実行・責任は秘密鍵の保持に強く結び付けられ、人間のオペレータおよび自律エージェントは不可逆な結果に対して直接的な責任を負う。この結合は、長期的な鍵管理、安全な自動化、および実行クリティカルなワークフローへの
AI エージェント統合において根本的な課題を生じさせる。

本論文では、指示・実行・責任を異なる役割および検証可能な状態遷移として明示的に分離する分散実行モデル「ZeroKey」を提案する。ZeroKey
において、署名は直接的に実行を意味しない。実行は、事前定義された条件と制約がオンチェインで満たされ検証された場合にのみ発動される。人間は実行制約を指定し、AI
エージェントはその制約内で候補指示を生成し、システムは条件付き認可による状態遷移を通じて実行を強制する。いかなる当事者も秘密鍵を継続的に保持する必要はない。

本論文では、ZeroKey
モデルを形式化し、具体的なシステム実装を通じてその実現可能性を示す。提案手法は、ブロックチェイン環境において安全で説明可能かつ監査可能な自律実行を可能にし、秘密鍵の露出および意図しないエージェント動作に関連するリスクを大幅に低減する。
\end{abstract}

\section{Introduction}\label{introduction}

\subsection{Problem Statement}\label{problem-statement}

現在のブロックチェインシステムにおいて、スマートコントラクトのデプロイや資産移動といった重要な操作は、秘密鍵による署名を通じて実行される。この設計では、\textbf{指示（何を実行するか）・実行（実際の処理）・責任（結果への帰属）}が、単一の秘密鍵、あるいは少数の鍵集合に強く結び付けられている。

この結合は、システムとしては単純である一方、実運用において複数の問題を引き起こす。第一に、人間が秘密鍵を長期間安全に管理し続けることは現実的に困難である。鍵の漏洩や誤操作は不可逆な結果をもたらし、ブロックチェイン技術の利用を高度な専門家に限定する要因となっている。第二に、業務自動化や運用効率化のために
AI エージェントを導入する場合、実行権限を直接 AI
に付与することは、安全性および責任の所在の観点から大きなリスクを伴う。

既存の解決策として、マルチシグネチャ、セッションキー、Account
Abstraction
などの手法が提案されているが、これらはいずれも「秘密鍵をどのように安全に扱うか」という枠組みの中で問題を解決しようとするものである。すなわち、\textbf{秘密鍵を人間またはエージェントが保持する前提自体は維持されたまま}であり、指示・実行・責任の結合という構造的問題は解消されていない。

本研究では、この前提そのものを問題として捉える。すなわち、「なぜ実行のために、人間や
AI
が秘密鍵を保持しなければならないのか」「なぜ署名は即座に実行を意味するのか」という点を問い直す。本論文が対象とする問題は、鍵管理の手法や
UX の改善ではなく、\textbf{実行モデルそのものの再設計}である。

特に本研究では、以下の点を未解決の問題として位置付ける：

\begin{itemize}
\tightlist
\item
  指示と実行が分離されていないことにより、誤操作や暴走の影響が直接的かつ不可逆に現れる点
\item
  実行結果に対する責任が、人や組織ではなく「どの状態が成立したか」という観点で定義されていない点
\item
  AI
  エージェントを安全に実行プロセスへ組み込むための、計算モデルレベルの整理が不足している点
\end{itemize}

これらの問題を解決するためには、秘密鍵管理の改善ではなく、\textbf{指示・実行・責任を分離し、それぞれを異なる主体および状態として扱う新しい分散実行モデル}が必要である。

\subsection{Contributions}\label{contributions}

本論文の主要な貢献は以下の通りである：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{ZeroKey モデルの提案}:
  指示・実行・責任を分離する新しい分散実行モデルの形式的定義
\item
  \textbf{ZeroKeyCI の実装}: 秘密鍵を保持しない CI/CD
  プラットフォームの設計と実装
\item
  \textbf{ZeroKey Treasury の実装}: AI
  駆動の実行ガバナンスレイヤーの設計と実装
\item
  \textbf{ケーススタディ}: 実装を通じたモデルの実現可能性と安全性の検討
\end{enumerate}

\section{Background and Related Work}\label{background-and-related-work}

\subsection{Traditional Key Management
Approaches}\label{traditional-key-management-approaches}

ブロックチェインにおける秘密鍵管理は、システムセキュリティの根幹をなす。従来のアプローチは以下のように分類される。

\subsubsection{Multi-signature Wallets}\label{multi-signature-wallets}

マルチシグネチャ（マルチシグ）は、複数の秘密鍵による署名を要求することで、単一障害点を排除する手法である。Gnosis
Safe に代表されるスマートコントラクトウォレットは、m-of-n
署名スキームを実装し、企業や DAO
における資産管理の標準となっている。しかし、マルチシグは「誰が署名するか」を分散させるものであり、各署名者が秘密鍵を保持する前提は変わらない。

\subsubsection{セッション
Keys}\label{ux30bbux30c3ux30b7ux30e7ux30f3-keys}

セッションキーは、一時的かつ制限された権限を持つ鍵を生成し、特定の操作に使用する手法である。これにより、マスタキーの露出リスクを低減できる。しかし、セッションキー自体も秘密鍵であり、その管理と
revocation のメカニズムが必要となる。

\subsubsection{Account Abstraction
(ERC-4337)}\label{account-abstraction-erc-4337}

Account Abstraction
は、トランザクションの署名と実行を抽象化し、任意の検証ロジックを許容する。これにより、ソーシャルリカバリやガスレストランザクションが可能となる。しかし、ERC-4337
は「どのように署名を検証するか」を柔軟にするものであり、「署名が必要である」という前提自体は維持される。

\subsection{Limitations of Existing
Approaches}\label{limitations-of-existing-approaches}

既存のアプローチに共通する限界は、\textbf{秘密鍵の保持を前提とした問題解決}である点にある。

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
アプローチ & 解決する問題 & 残存する問題 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
マルチシグ & 単一障害点 & 各署名者の鍵管理 \\
セッションキー & マスタキー露出 & セッションキー自体の管理 \\
Account Abstraction & 署名検証の柔軟性 & 署名の必要性 \\
\end{longtable}
}

これらはいずれも、「鍵をどう管理するか」という枠組みの中での改善であり、「なぜ鍵を保持しなければならないのか」という根本的な問いに答えていない。

\subsection{AI Agents in Blockchain}\label{ai-agents-in-blockchain}

AI
エージェントのブロックチェイン統合は、自律的な金融操作を可能にする一方で、新たなリスクをもたらす。x402
プロトコルのような自律支払い標準は、ボットやサービスが人間の介入なしに送金を開始することを許容する。しかし、これは誤設定、詐欺、ポリシー違反のリスクを増大させる。

AI エージェントに秘密鍵を直接付与することは、以下の問題を引き起こす：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{暴走リスク}: AI
  の判断ミスや悪意ある操作が即座に不可逆な結果をもたらす
\item
  \textbf{責任の曖昧さ}: AI の行動に対する法的・組織的責任の所在が不明確
\item
  \textbf{監査困難性}: AI の意思決定プロセスの透明性確保が困難
\end{enumerate}

\section{The ZeroKey Model}\label{the-zerokey-model}

\subsection{Design Principles}\label{design-principles}

ZeroKey モデルは、以下の設計原則に基づく。

\textbf{原則 1: 指示と実行の分離}

トランザクションの「提案」と「実行」を異なるフェーズとして扱う。提案者は実行権限を持たず、実行者は提案を生成しない。

\textbf{原則 2: 責任の状態化}

責任を「誰が署名したか」ではなく、「どの状態遷移が成立したか」として定義する。これにより、複数の主体による協調的な意思決定の監査が可能となる。

\textbf{原則 3: ゼロキー実行}

人間も AI
エージェントも、直接的に秘密鍵を保持する必要がない。署名権限は、条件付きの分散鍵システムによって管理される。

\subsection{Formal Model}\label{formal-model}

ZeroKey モデルを以下のように形式化する。

\textbf{定義 1 (Instruction)}: 指示 \(I\)
は、実行したい操作の意図を表現するタプルである。

\[I = (sender, target, action, params, metadata)\]

ここで、\(sender\) は指示の発行者、\(target\)
は対象コントラクト、\(action\) は操作種別、\(params\)
はパラメータ、\(metadata\) は追加情報である。

\textbf{定義 2 (Execution Context)}: 実行コンテキスト \(E\)
は、指示を実行するために必要な状態を表す。

\[E = (I, policies, riskAssessment, approvals)\]

\textbf{定義 3 (Accountability Record)}: 責任レコード \(A\)
は、実行結果とその監査情報を表す。

\[A = (E, txHash, outcome, explanation, タイムスタンプ)\]

\textbf{状態遷移}: ZeroKey モデルにおける状態遷移は以下の通りである。

\[\text{Instruction} \rightarrow \text{Validation} \rightarrow \text{Approval} \rightarrow \text{Execution} \rightarrow \text{Accountability}\]

本モデルの特徴は、トランザクションの生成・検証・実行を非同期かつ疎結合な状態遷移として扱う点にある。これにより、各フェーズを独立した主体が担当し、単一障害点を排除しながら、全体として一貫した実行保証を提供する。

\subsection{Role Separation}\label{role-separation}

ZeroKey モデルでは、以下の役割が明確に分離される。

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
役割 & 責任 & 権限 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Proposer & 指示の生成 & なし（署名権限なし） \\
Validator & ポリシー検証 & 承認/拒否の判定 \\
Approver & 最終承認 & マルチシグ署名 \\
Executor & トランザクション実行 & 条件付き署名（PKP） \\
Auditor & 監査と説明 & 読み取りのみ \\
\end{longtable}
}

\section{System Architecture}\label{system-architecture}

ZeroKey モデルを実装するシステムは、ZeroKeyCI と ZeroKey Treasury の 2
つのコンポーネントから構成される。図 1 に、ZeroKey
モデルの全体的な実行フローを示す。

\textbf{図 1: ZeroKey Execution Model}

\begin{verbatim}
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ZeroKey Execution Flow                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌────────┐ │
│  │Instruction│───▶│Validation│───▶│ Approval │───▶│Execution │───▶│ Audit  │ │
│  │ (Human/  │    │ (Policy  │    │(Multisig)│    │  (PKP)   │    │  Log   │ │
│  │   AI)    │    │  Engine) │    │          │    │          │    │        │ │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘    └────────┘ │
│       │               │               │               │               │      │
│       ▼               ▼               ▼               ▼               ▼      │
│   No Keys        Risk Level      m-of-n         Threshold        Immutable  │
│   Required       Assessment      Signatures     Cryptography     Records    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
\end{verbatim}

この図は、指示から監査までの各フェーズが独立した主体によって処理され、いかなる単一の主体も秘密鍵を継続的に保持しないことを示している。

\subsection{ZeroKeyCI: Keyless CI/CD
Platform}\label{zerokeyci-keyless-cicd-platform}

ZeroKeyCI は、GitHub Actions
を通じてスマートコントラクトをデプロイする際に、秘密鍵を一切保存しない
CI/CD プラットフォームである。

\subsubsection{Workflow}\label{workflow}

ワークフローは以下の通りである：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{PR マージ}: 開発者がコード変更をマージ
\item
  \textbf{テスト実行}: 自動テストによる検証（605+ テストケース）
\item
  \textbf{ポリシー検証}: Open Policy Agent
  によるセキュリティポリシーの強制
\item
  \textbf{PKP 署名}: Lit Protocol の分散鍵による条件付き署名
\item
  \textbf{Safe 実行}: Gnosis Safe マルチシグによる最終実行
\end{enumerate}

\subsubsection{Deployment Modes}\label{deployment-modes}

ZeroKeyCI は 2 つのデプロイモードを提供する。

\textbf{Manual Signing Mode（デフォルト）}: CI が Safe
マルチシグプロポーザルを生成し、オーナーが手動で承認する。

\textbf{PKP Automation Mode（オプション）}: Lit Protocol の Programmable
Key
Pairs（PKP）による完全自動署名。閾値暗号により、秘密鍵が完全な形で存在することはない。

\subsubsection{Technology Stack}\label{technology-stack}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
コンポーネント & 技術 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
コントラクトコンパイル & Hardhat \\
分散鍵管理 & Lit Protocol PKPs \\
マルチシグ & Gnosis Safe SDK \\
ポリシー検証 & Open Policy Agent \\
サポートネットワーク & Ethereum, Polygon, Arbitrum, Optimism, Base \\
\end{longtable}
}

\subsection{ZeroKey Treasury: AI-Governed Execution
Firewall}\label{zerokey-treasury-ai-governed-execution-firewall}

ZeroKey Treasury
は、すべての支払いとトレジャリー操作に対して、統一された安全性とガバナンスを提供する
AI 駆動の実行ファイアウォールである。

\subsubsection{Key Features}\label{key-features}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
機能
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
説明
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
AI セマンティック分析 &
トランザクションの意図、関数シグネチャ、コントラクトメタデータを検査 \\
ポリシーエンジン & 明示的ルールと履歴からの暗黙的パターンをサポート \\
オンチェイン強制 & リスクに基づいてリバート、承認要求、自動許可を行う \\
実行ファイアウォール &
すべての支払いはチェインに到達する前にこのレイヤーを通過 \\
説明可能性 & 自然言語による説明と不変の監査ログ \\
\end{longtable}
}

\subsubsection{Technology Stack}\label{technology-stack-1}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
レイヤー & 技術 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
スマートコントラクト & Solidity 0.8.24, Foundry \\
バックエンド & Hono, TypeScript, Zod \\
フロントエンド & Next.js 15, React 19, TailwindCSS \\
Web3 & Wagmi, Viem, RainbowKit \\
\end{longtable}
}

\section{Implementation}\label{implementation}

\subsection{Smart Contracts}\label{smart-contracts}

\subsubsection{ZeroKeyGuard.sol}\label{zerokeyguard.sol}

ZeroKeyGuard
は、トランザクションの実行前に検証を行うガードコントラクトである。

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interface IZeroKeyGuard \{}
\NormalTok{    function checkTransaction(}
\NormalTok{        address to,}
\NormalTok{        uint256 value,}
\NormalTok{        bytes memory data,}
\NormalTok{        uint8 operation,}
\NormalTok{        uint256 safeTxGas,}
\NormalTok{        uint256 baseGas,}
\NormalTok{        uint256 gasPrice,}
\NormalTok{        address gasToken,}
\NormalTok{        address payable refundReceiver,}
\NormalTok{        bytes memory signatures,}
\NormalTok{        address msgSender}
\NormalTok{    ) external view;}

\NormalTok{    function checkAfterExecution(}
\NormalTok{        bytes32 txHash,}
\NormalTok{        bool success}
\NormalTok{    ) external;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

ガードコントラクトは以下の検証を行う：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{リスクレベル判定}: AI ポリシーエンジンからのリスク評価を確認
\item
  \textbf{ポリシー準拠}: 明示的ルールとの整合性を検証
\item
  \textbf{承認状態}: 必要な承認が得られているかを確認
\end{enumerate}

\subsection{Backend Services}\label{backend-services}

\subsubsection{Transaction Analysis API}\label{transaction-analysis-api}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{interface}\NormalTok{ TransactionAnalysisRequest \{}
\NormalTok{  chainId}\OperatorTok{:} \DataTypeTok{number}\OperatorTok{;}
\NormalTok{  from}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{;}
\NormalTok{  to}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{;}
\NormalTok{  value}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{;}
\NormalTok{  data}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{interface}\NormalTok{ TransactionAnalysisResponse \{}
\NormalTok{  riskLevel}\OperatorTok{:} \StringTok{\textquotesingle{}LOW\textquotesingle{}} \OperatorTok{|} \StringTok{\textquotesingle{}MEDIUM\textquotesingle{}} \OperatorTok{|} \StringTok{\textquotesingle{}HIGH\textquotesingle{}} \OperatorTok{|} \StringTok{\textquotesingle{}CRITICAL\textquotesingle{}}\OperatorTok{;}
\NormalTok{  approved}\OperatorTok{:} \DataTypeTok{boolean}\OperatorTok{;}
\NormalTok{  reason}\OperatorTok{:} \DataTypeTok{string}\OperatorTok{;}
\NormalTok{  recommendations}\OperatorTok{:} \DataTypeTok{string}\NormalTok{[]}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

AI ポリシーエンジンは、以下の観点からトランザクションを分析する：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{コントラクト分類}: 対象コントラクトの種類と信頼性
\item
  \textbf{関数シグネチャ解析}: 呼び出される関数の意図
\item
  \textbf{資産フロー追跡}: 資産の移動先と金額
\item
  \textbf{履歴パターン}: 過去の類似トランザクションとの比較
\end{enumerate}

\subsection{Lit Protocol PKP
Integration}\label{lit-protocol-pkp-integration}

Lit Protocol の Programmable Key
Pairs（PKP）は、閾値暗号を用いた分散鍵システムである。

PKP の特徴：

\begin{itemize}
\tightlist
\item
  \textbf{分散閾値暗号}: 秘密鍵が完全な形で存在しない
\item
  \textbf{条件付き署名}: ポリシー条件を満たす場合のみ署名を生成
\item
  \textbf{プログラマブル}: 署名条件をコードで定義可能
\end{itemize}

\section{Evaluation}\label{evaluation}

\subsection{Security Analysis}\label{security-analysis}

\subsubsection{Attack Surface
Comparison}\label{attack-surface-comparison}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
攻撃ベクトル & 従来システム & ZeroKey \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
GitHub アカウント侵害 & 資金流出可能 & プロポーザル生成のみ \\
CI/CD パイプライン侵害 & 秘密鍵露出 & 鍵なし \\
単一署名者の鍵漏洩 & 即時資金流出 & Safe マルチシグで保護 \\
AI エージェントの暴走 & 直接実行可能 & ポリシーエンジンで阻止 \\
\end{longtable}
}

\textbf{従来システム}: 1 つの侵害された GitHub
アカウント（リポジトリアクセス付き）で資金流出が可能

\textbf{ZeroKey}: 2/3 以上の Safe オーナーのハードウェアウォレットが必要

\subsubsection{Threat Model}\label{threat-model}

ZeroKey は以下の脅威に対して耐性を持つ：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{内部脅威}: 単一の内部者による不正操作
\item
  \textbf{外部侵害}: CI/CD インフラへの攻撃
\item
  \textbf{AI 暴走}: エージェントの意図しない動作
\item
  \textbf{ポリシー違反}: 組織規程に反する操作
\end{enumerate}

\subsection{Efficiency Analysis}\label{efficiency-analysis}

\subsubsection{Deployment Time}\label{deployment-time}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
項目 & 手動デプロイ & ZeroKeyCI \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
総所要時間 & 35 分 & 3-4 分 \\
高速化率 & - & 10x \\
\end{longtable}
}

\subsubsection{Gas Optimization}\label{gas-optimization}

実際のシナリオ（ERC-721 デプロイ）：

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ネットワーク & ガス費用 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Ethereum Mainnet & \$180 \\
Polygon（ZeroKey 推奨） & \$2.50 \\
削減率 & 98.6\% \\
\end{longtable}
}

\subsection{Audit Trail}\label{audit-trail}

ZeroKey は完全な監査証跡を提供する：

\[\text{PR} \rightarrow \text{CI Logs} \rightarrow \text{Policy Decision} \rightarrow \text{Safe Proposal} \rightarrow \text{On-chain Tx}\]

従来システムでは GitHub の監査ログのみに依存するが、ZeroKey
は以下を記録する：

\begin{itemize}
\tightlist
\item
  ポリシー評価結果と理由
\item
  AI のリスク判定プロセス
\item
  各承認者の署名タイムスタンプ
\item
  オンチェイントランザクションハッシュ
\end{itemize}

\section{Discussion}\label{discussion}

\subsection{ZeroKey vs Traditional
Proxies}\label{zerokey-vs-traditional-proxies}

ZeroKey はトランザクションのフローに介在するが、単なるプロキシではない。

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
観点 & 従来のプロキシ & ZeroKey Treasury \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
理解 & 生データの中継 & 深いセマンティック分析 \\
ポリシー & なし & 明示的 + 暗黙的ルール \\
強制 & パススルー & オンチェインガードコントラクト \\
透明性 & なし & 完全な説明可能性 \\
\end{longtable}
}

ZeroKey Treasury
は、自律金融のための基盤的な\textbf{実行ガバナンスレイヤー}となる。

\subsection{Limitations}\label{limitations}

本研究には以下の制限がある：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{レイテンシ}: AI 分析とポリシー検証による追加遅延
\item
  \textbf{コスト}: ガードコントラクトの追加ガス消費
\item
  \textbf{複雑性}: システム全体の運用複雑性の増加
\item
  \textbf{依存性}: Lit Protocol、Safe 等の外部サービスへの依存
\end{enumerate}

\subsection{Future Work}\label{future-work}

今後の研究課題として以下を挙げる：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{マルチチェイン対応の拡充}:
  クロスチェイントランザクションへの対応
\item
  \textbf{AI モデルの改善}: より高精度なリスク判定
\item
  \textbf{形式検証}: ガードコントラクトの形式的安全性証明
\item
  \textbf{プライバシー保護}: ゼロ知識証明を用いた監査情報の秘匿化
\end{enumerate}

\section{Conclusion}\label{conclusion}

本論文では、ブロックチェインにおける秘密鍵への過度な依存という構造的問題に対し、ZeroKey
モデルを提案した。ZeroKey
は、指示・実行・責任を分離する新しい分散実行モデルであり、以下の貢献を行った。

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  秘密鍵を人間や AI が直接保持しない実行モデルの設計
\item
  ZeroKeyCI による CI/CD パイプラインのキーレス化
\item
  ZeroKey Treasury による AI 駆動の実行ガバナンス
\item
  従来手法と比較した 10 倍の効率化と攻撃表面の大幅削減
\end{enumerate}

ZeroKey
は、自律金融の時代における安全な実行基盤として、ブロックチェイン技術の大衆化に貢献することが期待される。

\section{References}\label{references}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Buterin, V. et al.~``ERC-4337: Account Abstraction Using Alt
  Mempool.'' Ethereum Improvement Proposals, 2021.
\item
  Gnosis. ``Safe: Programmable Accounts.'' https://safe.global/
\item
  Lit Protocol. ``Programmable Key Pairs.''
  https://developer.litprotocol.com/
\item
  Open Policy Agent. ``Policy-based control for cloud native
  environments.'' https://www.openpolicyagent.org/
\item
  ETHGlobal. ``Bangkok 2024 Hackathon.''
  https://ethglobal.com/events/bangkok
\end{enumerate}

\end{document}
